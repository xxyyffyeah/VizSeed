var g=Object.defineProperty,m=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var c=Object.getOwnPropertySymbols;var f=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var i=(e,n,o)=>n in e?g(e,n,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[n]=o,a=(e,n)=>{for(var o in n||(n={}))f.call(n,o)&&i(e,o,n[o]);if(c)for(var o of c(n))h.call(n,o)&&i(e,o,n[o]);return e},l=(e,n)=>m(e,u(n));const B=e=>{const{dimensions:n,measures:o}=e;return{x:o[0],y:n[0],group:n[1]}},H=(e,n)=>{const{fieldSelection:o}=n;if(!o||o.dimensions.length===0&&o.measures.length===0)return e;console.log("🎨 水平条形图自动通道映射，字段选择:",o);const d=B(o),s={};Object.entries(d).forEach(([p,t])=>{t!=null&&(s[p]=t)}),console.log("🔗 水平条形图通道映射结果:",s);const r=[s];return n.encodes=r,l(a({},e),{encodes:r})};export{H as m};
//# sourceMappingURL=HorizontalBarMapping--AjkKkU-.js.map
