var p=Object.defineProperty,g=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var f=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var c=(s,n,e)=>n in s?p(s,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[n]=e,l=(s,n)=>{for(var e in n||(n={}))f.call(n,e)&&c(s,e,n[e]);if(r)for(var e of r(n))h.call(n,e)&&c(s,e,n[e]);return s},a=(s,n)=>g(s,u(n));const _=s=>{const{dimensions:n,measures:e}=s;return{x:n[0],y:e[0],color:n[1]||(e.length>1?"__MeasureName__":void 0)}},E=(s,n)=>{const{fieldSelection:e}=n;if(!e||e.dimensions.length===0&&e.measures.length===0)return s;console.log("🎨 时间序列自动通道映射，字段选择:",e);const d=_(e),o={};Object.entries(d).forEach(([m,t])=>{t!=null&&(o[m]=t)}),console.log("🔗 时间序列通道映射结果:",o);const i=[o];return n.encodes=i,a(l({},s),{encodes:i})};export{E as m};
//# sourceMappingURL=TimeSeriesMapping-DgzfgjTS.js.map
